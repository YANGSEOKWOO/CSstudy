
이전 : 컴퓨터 : 명령어를 처리하는 기계
하지만, 우리가 코드를 짜는 C, Java 같은 프로그래밍 소스코드는 명령어가 아닌데?

소스코드 => 컴퓨터 내부에서 명령어로 변환된다.

## 고급언어와 저급언어

컴퓨터는 프로그래밍언어를 이해하지 못한다.

고급언어 : 사람을 위한 언어, 사람이 이해하고 작성하기 쉽게 만들어진 언어
저급언어 : 컴퓨터가 직접 이해하고 실행할 수 있는 언어 => **명령어로 이뤄져있다**

따라서 고급언어로 작성된 소스코드가 실행되려면, 반드시 저급언어(명령어)로 변환되어야 한다.

#### 저급언어
- 기계어 : 01로 이뤄진 명령어
- 어셈블리어 : 0, 1로 표현된 명령어를 읽기 편한 형태로 번역한 언어

![[Pasted image 20240217152943.png]]
```assembly
push rbp
mov rbp, rsp
mov DWORD PTR [rbp-4], 1
mov DWORD PTR [rbp-8], 2
mov edx, DWORD PTR [rbp-4]
mov eax, DWORD PTR [rbp-8]
add eax, edx
mov DWORD PTR [rbp-12], eax
mov eax, 0
pop rbp
ret
```
한  줄 : 명령어

왜 저급언어를 알아야 할까?
- 하드웨어와 밀접하게 닿아있는 프로그램, 임베디드, 게임, 정보보안은 어셈블리어 사용함
어셈블리어 => 컴퓨터가 프로그램을 어떤 과정으로 실행하는 지, 프로그램이 어떤 절차로 작동하는지
근본적인 단계에서부터 하나하나 추적하고 관찰할 수 있다.


### 컴파일 언어, 인터프리터 언어
고급언어로 작성한 소스코드 => 저급언어
- 어떻게 변환될까?
- 컴파일 방식, 인터프리트 방식이 있다.

#### 컴파일 언어
**컴파일러**에 의해 **소스코드 전체**가 저급언어로 변환되어 실행되는 고급언어
컴파일 : 코드 전체가 저급언어로 변환되는 과정
컴파일러 : 컴파일을 수행해주는 도구
ex) C언어

![[Pasted image 20240217154008.png]]

#### 인터프리터 언어
인터프리터에 의해 **소스 코드가 한 줄씩** 실행되는 고급언어
소스코드 전체를 저급 언어로 변환하는 시간을 기다릴 필요가 없다.
N번째에 오류가 있더라도, N-1번째 줄까지는 올바르게 수행된다.
ex) Python

속도
인터프리터 언어 < 컴파일 언어
- 인터프리터 언어는 소스코드 마지막에 이를 때까지 한 줄 한줄씩 저급언어로 해석하며 실행해야 하기 때문

하지만 둘을 명시적으로 막 구별하지는 않음, 그런게 있다 방식이 있다~ 정도만


#### 목적파일 vs 실행파일
목적파일 : 목적코드로 이뤄진 파일
실행파일 : 실행코드로 이뤄진 파일

목적 코드가 실행파일이 되려면? => **링킹**작업을 거쳐야 한다.
main.c 파일
```c
helper.c에 있는 HELPER_더하기

화면_출력 라이브러리
```
helper.c 파일
```c
HELPER_더하기
```

상황 : main.c에는 helper.c에 구현된 HELPER_더하기 라는 함수와 화면_출력이라는 기능을 가져다 사용한다.

컴파일을 한다면 목적코드가 생성된다. (helper.o, main.o)
이때 main.o는 바로 실행될 수 없다.
- 왜냐면 main.c에는 HELPER_더하기가 구현되지 않았기 때문,
- main.o에 없는 외부 기능, HELPER_더하기, 화면_출력기능을 연결짓는 작업이 필요함
- 이게 링킹!
- 이 후에 하나의 실행파일이 만들어 진다.

