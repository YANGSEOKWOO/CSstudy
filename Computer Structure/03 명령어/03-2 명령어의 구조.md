## 연산코드와 오퍼랜드

명령어

"영수야, 방 좀 치워"
'무엇을 대상으로, 어떤 작동을 수행해라'

작동 => 연산
#### 명령어
![[Pasted image 20240217155347.png]]
핑크 배경 : 연산 => **연산코드**, **연산자**
흰색 배경 : 연산에 사용할 데이터, 연산에 사용할 데이터가 저장된 위치 => **오퍼랜드**, **피연산자**

이렇듯 명령어는 (연산코드, 오퍼랜드), (연산자, 피연산자)로 이뤄져있다.
```assemble
push rbp
mov rbp

```

왼쪽이 연산코드, 오른쪽이 오퍼랜드이다.

#### 오퍼랜드
- 연산에 사용할 데이터, 연산에 사용할 데이터가 저장된 위치
- 올 수 있는 것 : 데이터(숫자, 문자), 주소(메모리, 레지스터)
- 보통은 데이터를 명시하기 보단, 주소를 더 많이 담는다.
- 그래서 오버랜드 필드 = 주소필드

![[Pasted image 20240217160253.png]]
이렇게 오퍼랜드가 하나일 수도 있고, 3개 일 수도 있다.

#### 연산코드
명령어가 수행할 연산

유형 4가지
1. 데이터전송
2. 산술/논리 연산
3. 제어 흐름 변경
4. 입출력 제어
명령어의 종류, 생김새는 CPU마다 다르다


#### 주소 지정 방식
'명령어의 오퍼랜드 필드에 메모리나 레지스터의 주소를 담는 경우가 많다.'
=> 왜 굳이 주소를 담을까?

**명령어의 길이** 때문

명령어가 16비트, 연산코드 비트가 4비트, 2-주소 명령어라면
오퍼랜드에게 할당되는건 필드당 6비트이다.
=> 하나의 오퍼랜드 필드로 표현할 수 있는 정보의 가짓수는 2^6개밖에 되지 않는다.

하지만 메모리주소가 담긴다면?
표현할 수 있는 데이터의 크기가, 하나의 메모리 주소에 저장할 수 있는 공간만큼 커진다.
![[Pasted image 20240217160929.png]]

예시아닌 예시를 들자면
내가 A4용지에 글을 쓸 때 공간이 부족한거임, 그래서 거기다가 "뒷 내용은 어디다가 써놨음" 이라고 해놓으면 주소를 지정해논거고
다른 사람은 그걸 보고 주소를 찾아서 더 길게 쓴 글을 볼 수 있다는 거임

**유효주소** : 연산의 대상이 되는 데이터가 저장된 위치
**주소지정방식** : 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때, **사용할 데이터의 위치를 찾는 방법**

#### 즉시 주소 지정 방식
연산에 사용할 데이터를 **오퍼랜드 필드에 직접 명시**하는 방식
장점 : 빠르다 ( 데이터를 메모리, 레지스터로부터 찾을 필요 없음)
단점 : 표현할 수 있는 데이터의 크기가 작다.
![[Pasted image 20240217161430.png]]

#### 직접주소 지정방식
오퍼랜드 필드에 **유효 주소를 직접적으로 명시**하는 방식
장점 : 표현할 수 있는 데이터의 크기는 즉시 주소지정 방식보다 커졌다
단점 : 유효 주소를 표현할 수 있는 범위가 연산코드의 비트 수 만큼 줄어든다.
- 표현할 수 있는 유효주소에 제한이 생길 수 있다.

![[Pasted image 20240217161450.png]]
#### 간접 주소 지정방식
유효주소의 주소를 오퍼랜드 필드에 명시하는 것
장점 : 직접주소 지정방식보다 표현할 수 있는 유효 주소의 범위가 넓어진다.
단점 : 느리다 (두 번의 메모리 접근)

![[Pasted image 20240217161503.png]]

#### 레지스터 주소 지정방식
직접주소지정하고 비슷함
연산에 사용할 데이터를 저장한 레지스터를 **오퍼랜드 필드에 직접 명시**하는 방법
장점 : 빠르다 ( CPU내부에 있는 레지스터라서)
단점 : 직접주소지정과 동일(표현할 수 있는 레지스터 크기에 제한)
![[Pasted image 20240217161521.png]]

#### 레지스터 간접 주소 지정 방식
연산에 사용할 데이터를 저장하고, 그 **주소를 저장한 레지스터를 오퍼랜드 필드에 명시**하는 방법
장점 : 메모리 접근 횟수 1번
![[Pasted image 20240217162102.png]]
