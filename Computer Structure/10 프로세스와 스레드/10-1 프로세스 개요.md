**프로세스**
- 프로그램이 메모리에 적재되고 실행되는 순간, 프로그램은 프로세스가 된다.
- 실행중인 프로그램
- 보조기억장치에 있는 프로그램이 메인 메모리에 적재되고 실행되면 프로세스가 된다는거임

### 프로세스 직접 확인하기

![[Screenshot 2024-02-25 at 2.13.14 PM.png]]
`ps -ef` 명령어를 통해 보면, 여러 프로세스가 실행중인 것을 알 수 있다.
프로세스는 2개의 실행이 있는데
1. 포그라운드 프로세스
	1. 사용자가 보는 앞에서 실행되는 프로세스
2. 백그라운드 프로세스 -**데몬, 서비스**
	1. 사용자가 보지 못하는 뒤편에서 실행되는 프로세스
	2. 사용자와 상호작용할 수 있는 프로세스
	3. 상호작용X, 묵묵히 정해진 일만 수행하는 프로세스

### 프로세스 제어 블록

사유
모든 프로세스는 실행을 하기 위해서 CPU가 필요하다.
**하지만 CPU의 자원은 한정적이다. => 모든 프로세스가 CPU를 동시에 사용할 수는 없다.**
따라서, 차례차례 번갈아가며 한정된 시간 만큼만 CPU를 사용한다.
- 자기 차례때 CPU를 이용하고, 시간이 끝났으면 양보한다.

![[Pasted image 20240225142124.png]]

#### PCB (프로세스 제어 블록) Process Control Block
운영체제는 PCB를 통해
- 프로세스의 실행순서를 관리한다.
- 프로세스에 CPU 및 자원을 배분한다.
PCB : 프로세스와 관련된 정보를 저장하는 자료구조
- 프로세스에 달려있는 태그라고 생각하면 된다.
- 해당 프로세스를 식별하기 위해 필요한 정보들이 저장된다.
PCB는 커널 영역에 생성된다.
- **운영체제는 PCB를 통해 특정 프로세스를 식별한다.**
**생성과 폐기**
- 생성 : 프로세스 생성시
- 폐기 : 프로세스 실행이 끝나면
=> '새로운 프로세스가 생성되었다' == '운영체제가 PCB를 생성했다.'
=> '프로세스가 종료되었다.' == '운영체제가 해당 PCB를 폐기했다.'

#### PCB에 담기는 정보
프로세스 ID (PID)
- 프로세스를 식별하기 위해 부여하는 고유한 번호
- ex) 학번

레지스터 값
- 프로세스는 자신의 실행차례가 돌아오면 이전까지 사용했던 레지스터의 중간값들을 모두 복원한다. => 이전까지 진행했던 작업을 그대로 이어 실행할 수 있으니까!
- PCB안에는 해당 프로세스가 실행하며 사용했던 PC 등 레지스터 값들이 담긴다.

프로세스 상태
- 입출력장치를 사용하기 위해 기다리고 있는 상태인지
- CPU를 사용하기 위해 기다리고 있는 상태인지
- CPU를 이용하는 상태인지... 등등

CPU 스케줄링 정보
- 프로세스가 언제, 어떤 순서로 CPU를 할당받을지에 대한 정보

메모리 관리 정보
- 프로세스마다 메모리에 저장된 위치가 다르다.
- 그래서 PCB에는 프로세스가 어느 주소에 저장되어있는지에 대한 정보가 있어야 한다.
- Base register, 한계 register
- 페이지 테이블 정보도 PCB에 담긴다.

사용할 파일과 입출력 목록

![[Pasted image 20240225143056.png]]

### 문맥 교환 (Context Switching)

A프로세스가 작업중이다가 B프로세스가 실행된다고 하자.
- A프로세스의 작업 내용은 어디다가 저장할 것인가?
- B프로세스의 작업 내용은 어디서 불러올 것인가?

아까 말했던 PCB이다.

**하나의 프로세스 수행을 재개하기 위해 기억해야할 정보 : Context**

A의 작업내용을 PCB에 저장해놓고, B의 작업내용을 PCB를 통해 불러오는 것이다.
![[Pasted image 20240225143437.png]]

이 방법을 통해, 사용자 입장에서는 프로그램이 동시에 실행이 되는 것 처럼 보일 수 있다.

단점
- 근데, 프로세스가 교환될 때마다. 양끝의 PCB를 2번 봐야하기 때문에 시간에 대한 오버헤드가 커진다.


### 프로세스의 메모리 영역

프로세스의 생성
PCB : 커널영역에 생성된다.
사용자영역에는 프로세스가 어떻게 배치될까?
**=> 코드영역, 데이터영역, 힙 영역, 스택 영역으로 나뉘어 저장된다.**

![[Pasted image 20240225143850.png]]
#### 코드영역
코드영역 = 텍스트영역

실행할 수 있는 코드 = 기계어로 이뤄진 명령어가 저장된다.

~~데이터가 저장된다.~~ => CPU가 실행할 명령어가 담겨있다.
**따라서 쓰기가 금지되어 있다.**

=> 코드영역은 읽기 전용 공간이다.
정적 할당 영역
#### 데이터 영역
프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간
- ex) 전역변수

크기가 변하지 않는다.
- 명령어가 바뀌지 않기 때문에!

정적 할당 영역

#### 힙 영역
프로그래머가 직접 할당할 수 있는 저장공간
- 메모리 공간을 할당했다면 , 언젠가 해당 공간을 반환해야 한다.
- => '더 이상 해당 메모리 공간을 사용하지 않겠다.'
- 메모리 누수 : 메모리 낭비

#### 스택영역
데이터를 일시적으로 저장하는 공간
- 잠깐 쓰다가 말 값
- ex) 매개변수, 지역변수
![[Pasted image 20240225144403.png]]