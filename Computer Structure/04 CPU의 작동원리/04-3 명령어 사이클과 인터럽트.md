**명령어 사이클** : CPU가 하나의 명령어를 처리하는 정형화된 흐름
**인터럽트** : 흐름이 끊어지는 상황


### 명령어 사이클
- CPU는 명령어들을 하나씩 실행한다.
- 각각의 명령어들은 일정한 주기가 반복되며 실행된다
- 주기 : **명령어 사이클**

#### 명령어의 실행
1. 명령어를 메모리에서 CPU로 가져와야 한다. : **인출 사이클**
2. 명령어를 실행한다. : **실행 사이클**
	1. 제어장치가 명령어 레지스터에 담긴 값을 해석하고, 제어 신호를 발생시키는 단계
	이 인출, 실행사이클을 반복하며 실행한다.
또한 메모리 접근을 한 번 더 해야하는 경우 : **간접 사이클** 이라고 한다.

### 인터럽트
CPU의 작업을 방해하는 신호

#### 동기 인터럽트
CPU에 의해 발생하는 인터럽트
- ex) CPU가 실행하는 프로그래밍 상의 오류와 같은 예외적인 상황에 마주쳤을 때 발생하는 인터럽트
- 예외라고 부른다.
#### 비동기 인터럽트 
주로 입출력 장치에 의해 발생하는 인터럽트
- CPU가 입출력장치에 작업을 부탁하면, 작업이 끝난 애가 CPU에 완료알림(인터럽트)를 보낸다.

**하드웨어 인터럽트**
순서
1. 입출력장치 => CPU에 **입터럽트 요청 신호**
2. CPU는 실행사이클이 끝나고, 명령어를 인출하기 전 항상 인터럽트 여부 확인
3. CPU는 인터럽트 요청을 확인하고 **인터럽트 플래그**를 통해 현재 인터럽트를 받아들일 수 있는지 여부 확인
4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업한다.
5. CPU는 **입터럽트 벡터**를 참조하여 **인터럽트 서비스 루틴**을 실행한다.
6. 인터럽트 서비스루틴 실행이 끝나면 4에서 백업한 작업 복구하여 실행 재개

**인터럽트 요청 신호**
![[Pasted image 20240218133631.png]]

CPU는 플래그 레지스터의 **인터럽트 플래그**가 활성화 되어있어야 한다.
CPU가 정말 중요한 작업처리중이라면 => 인터럽트 플래그를 불가능으로 설정
- 하지만 정전, 하드웨어 고장으로 인한 인터럽트는 막을 수 없다.

**인터럽트 서비스 루틴** = **인터럽트 핸들러**
인터럽트를 처리하기 위한 프로그램
- '~가 ~인터럽트 요청을 보낼 때는 ~하도록 작동한다.'
- 어떤식으로 처리하고 작동해야할 지에 대한 정보가 있다.
![[Pasted image 20240218133959.png]]

**인터럽트 벡터**
수많은 인터럽트 서비스루틴을 구분하기 위한 것
- 인터럽트 서비스 루틴의 시작주소를 알 수 있다.

결론 : **인터럽트**가 발생하면, 기 존거는 저장해놓고 끝내고 와서 저장했던 부분부터 다시 처리한다는 거임

CPU의 실행을 고려할 때, 만약 PC가 1500일 때 인터럽트가 발생하여 10번지에서 인터럽트를 발생시켜야 한다.

그렇다면 1500이 10으로 바뀔텐데 덮어써야할까?
아니다.

끝나고 나서 되돌아와야하기 때문에 **스택영역**에 작업내역을 백업해놓는다.

**인터럽트 요청 신호** : CPU의 작업을 방해하는 인터럽트에 대한 요청
**인터럽트 플래그** : 인터럽트 요청 신호를 받아들이지 무시할지 결정하는 비트
**인터럽트 백터** : 인터럽트 서비스루틴의 시작주소 + 식별정보
**인터럽트 서비스 루틴** : 인터럽트를 처리하는 프로그램

![[Pasted image 20240218134713.png]]

![[Pasted image 20240218135224.png]]
폴트 : 예외를 처리한 직후 예외가 발생한 명령어부터 실행을 재개하는 예외
트랩 : 예외를 처리한 직후 예외가 발생한 명령어의 다음 명령어부터 실행을 재개하는 예외
중단 : CPU가 실행중인 프로그램을 강제로 중단시킬 수 밖에 없는 심각한 오류를 발견했을 때 발생하는 예외


