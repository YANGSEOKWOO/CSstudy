> 명령어를 빠르고 효율적으로 처리하기 위해 CPU를 한시도 쉬지 않고 작동시키는 명령어 병렬처리 기법

## 명령어 파이프라인

#### 명령어 처리과정 (클럭단위)
1. 명령어 인출 (Instruction Fetch)
2. 해석 (Decode)
3. 명령어 실행 (Execute Instruction)
4. 결과 저장 (Write back)

중요한 점 : **같은 단계가 곂치지만 않으면, 각 단계를 동시에 실행할  수 있다.**
![[Pasted image 20240218141930.png]]

이렇게 하면 개꿀딱지가 아닐까!
하지만, 특정 상황에서는 성능 향상에 실패하는 경우도 있다.
## 파이프라인 위험
- 데이터위험
- 제어위험
- 구조적 위험

### 데이터 위험
**데이터 의존성**에 의해 발생한다.
- 특정 명령어는 기존 명령어가 실행이 다 된 후에만 비로소 실행되는 명령어가 있다.
``` 
명령어 1 : R1 <- R2 + R3
명령어 2 : R4 <- R1 + R5
```
이럴 때는 명령어 1이 완전히 실행이 되어야지 명령어 2가 가능해진다.
- **명령어 2가 명령어 1에 데이터 의존적**

### 제어 위험
**PC의 갑작스러운 변화**에 의해 발생 (분기)

ex) 원래는 1,2,3순으로 명령어가 실행되어야 하는데 1하고나서 갑자기 4로 실행을 해야하는 상황이 생김 if문 같은 느낌.
그래서 2,3을 먼저 준비하고 있었는데 쓸모가 없어진 거지

대처법 : **분기예측**

### 구조 위험 = 자원위험
서로 다른 명령어가 **동시에 ALU, 레지스터 등과 같은 CPU부품을 사용**하려 할 때 발생


### 슈퍼 스칼라
이 전까지는 단일 파이프라인이지만
오늘 날의 CPU는 여러 개의 파이프라인을 사용한다.
=> CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조 => 슈퍼스칼라
![[Pasted image 20240218142743.png]]
공장 생산 라인이 여러 개!
장점 : (이론적) 파이프라인 개수에 비례하여 프로그램 처리 속도가 빨라진다.
단점 : 파이프라인 위험을 방지하기 위해 고도로 설계되어야 함

### 비순차적 명령어 처리
명령어들을 순차적으로 실행하지 않는 기법
```
M(100) <- 1
M(101) <- 2
M(102) <- M(100) + M(101)
M(150) <-1
M(151) <-2
M(152) <-3
```
이때 3번째는 1,2 명령어가 다 실행될 때까지 기다려야 한다.
하지만 4, 5는 1, 2명령어와 관계없이 실행된다
=> **순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하여 명령어 파이프라인이 멈추는 것을방지하는 기법**
