CPU 스케줄링 : 운영체제가 프로세스들에게 공정하고 합리적으로 CPU자원을 배분하는 것
- 어떤 프로세스에게 CPU를 할당할 지
- 어떤 프로세스를 기다리게 할 지


### 프로세스 우선순위

프로세스들이 cpu를 할당받고 싶다고 하자
선착순으로 할당을 해주면 되는게 아닌기? 라고 생각을 할 수 있다.

하지만 프로세스마다  우선순위가 있다.

프로세스마다
- 입출력 장치를 많이 쓴다. : **입출력 집중 프로세스**
- CPU작업을 많이 한다. : **CPU 집중 프로세스**
가 차이가 난다는 것

CPU 집중 프로세스와 입출력 집중 프로세스가 동시에 CPU자원을 요구했을 때, 입출력 집중 프로세르를 가능한 한 빨리 실행시켜 입출력장치를 끊임없이 작동시키고 CPU 집중 프로세스에 집중적으로 CPU를 할당하는 것이 더 효율적일거임

왜냐면 입출력 집중 프로세스는 금방 대기상태가 될 예정이기 때문

=> 결론적으로, 프로세스마다 특징, 우선순위가 다르기 때문에 선착순으로 처리하는 것과는 차이가 많이 난다는 것

그래서 프로세스의 중요도에 맞게, 프로세스가 CPU를 이용할 수 있도록 하기 위해 운영체제는 프로세스마다 **우선순위**를 부여한다.
- PCB에 우선순위를 명시함


#### 스케줄링 큐
PCB에 적혀있지만, CPU가 다음 프로세스를 찾기 위해 일일이 모든 프로세스를 뒤적거리는 건 굉장히 비효율적이다!

따라서, 운영체제는 프로세스가 '줄서서 기다릴 것'을 원한다.
CPU를 사용하고 싶은 프로세스들, 메모리에 적재되고 싶은 프로세스들, .... 등등 모두 줄 세우는 것이다.
![[Pasted image 20240227194707.png]]
운영체제가 관리하는 대부분의 자원은 큐로 관리된다.
**준비 큐** : CPU를 이용하고 싶은 프로세스들이 서는 줄
**대기 큐** : 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄

![[Pasted image 20240227194941.png]]
1. 대기큐에서 기다린다.(입출력 작업이 완료되기 까지)
2. 입출력이 완료되고, 완료 인터럽트가 발생하면 작업이 완료된 PCB를 찾고 PCB를 준비상태로 변경한 후 대기큐에서 제거
3. 해당 PCB는 준비 큐로 이동한다.


#### 선점형과 비선점형 스케줄링

만약 지금 당장 CPU를 써야하는 프로세스가 있다.
하지만 다른 프로세스가 CPU를 사용하고 있는 상황

그러면 어떻게 해야할까?
1. 쓰고 있는 애를 강제로 CPU자원을 뺏는 방법 => 선점형 스케줄링
2. 다 쓸때까지 기다리는 방법 => 비선점형 스케줄링

#### 선점형 스케줄링
프로세스가 CPU를 비롯한 자원을 사용하고 있더라도, 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에게 할당할 수 있는 스케줄링 방식
- 어느 하나의 프로세스가 자원 사용을 독점할 수 없는 스케줄링 방식
장점 : 자원 독점을 막고, 골고루 프로세스에게 자원을 배분할 수 있다.
단점 : context switching에서의 오버헤드
#### 비선점형 스케줄링
하나의 프로세스가 자원을 사용하고 있다면, 그 프로세스가 종료되거나, 스스로 대기 상태에 접어들기 전 까진 다른 프로세스가 끼어들 수 없는 스케줄링 방식
- 하나의 프로세스가 자원 사용을 독점할 수 있는 스케줄링 방식
장점 : context switching이 적다
단점 : 모든 프로세스가 골고루 자원을 사용할 수 없다.








