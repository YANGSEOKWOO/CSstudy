장치컨트롤러는 CPU와 어떻게 정보를 주고 받을까?
- 프로그램 입출력
- 인터럽트 기반 입출력
- DMA 입출력


## 프로그램 입출력
프로그램 속 명령어로 입출력 장치를 제어하는 방법

입출력 명령어를 만나면!, 그때 CPU의 입출력장치에 연결된 장치 컨트롤러와 상호작용하며 입출력을 수행한다.

메모리에 저장된 정보를 하드 디스크에 백업하는 상황
1. '메모리에 저장된 정보를 하드디스크에 백업한다.'
2. CPU가 하드디스크 컨트롤러의 제어레지스터에 쓰기 명령을 보낸다.
3. 그러면 컨트롤러가 디스크의 상태를 확인하고, 상태 레지스터에 준비완료를 한다.
4. CPU가 상태 레지스터를 주기적으로 읽어보면서 하드디스크의 준비 여부를 확인, 준비됐다면 데이터 레지스터에 쓴다.

여기서 의문

입출력 작업 : CPU가 장치 컨트롤러의 레지스터 값을 읽고 쓴다.

어떻게 입출력장치의 주소를 알까? => 장치컨트롤러의 레지스터를 알까?

명령어는 어떻게 표현되고, 메모리에 어떻게 저장되어 있을까?

2가지 방식이 있다.
- 메모리맵 입출력
- 고립형입출력

#### 메모리 맵 입출력

메모리에 접근하기 위한 주소공간 + 입출력장치에 접근하기 위한 주소공간 = 하나의 주소공간으로 간주

![[Pasted image 20240219142557.png]]
메모리 주소, 장치컨트롤러의 레지스터들이나 모두 똑같이 메모리 주소를 대하듯하면 된다.

#### 고립형 입출력
메모리 주소공간, 입출력 주소공간을 분리하는 방법
![[Pasted image 20240219142727.png]]
(입출력 읽기/쓰기 선)을 따로 구별하는 거임
메모리 주소공간이 축소되지 않는다.
입출력 전용 명령어를 사용해야 한다.

![[Pasted image 20240219142829.png]]

## 인터럽트 기반 입출력

인터럽트 : 'CPU가 입출력장치에 처리할 내용을 명령하면 입출력장치가 명령어를 수행하는 동안 CPU는 다른 일을 할 수 있다.'
- '입출력장치가 CPU에게 인터럽트 요청을 보내면 CPU는 하던 일을 멈추고, 해당 인터럽트를 처리하는 프로그램인 인터럽트 서비스 루틴을 실행한 뒤 다시 하던 일로 되돌아 온다.'

정확히 말하면 입출력장치가 가인, 장치컨트롤러가 인터럽트를 거는 것이다.
![[Pasted image 20240219143539.png]]
![[Pasted image 20240219143548.png]]

CPU는 장치컨트롤러에 입출력 작업을 명령하고
장치컨트롤러가 입출력장치를 제어하며 입출력을 수행한다.
- CPU는 다른일
끝나면 CPU에게 다시 인터럽트
CPU는 하던 일을 백업하고 ISR(인터럽트 서비스 루틴)을 실행한다.

하지만, 키보드, 모니터, 스피커, 마우스 .... 등등 인터럽트가 동시에 발생할 때는 어떻게 처리할까?

1. 순차적으로 해결하는 방법
![[Pasted image 20240219143800.png]]
A의 서비스루틴이 끝나고 나서 B를 실행시키면 된다.
하지만 현실적으로는 우선순위를 고려해야할 때가 많다.
2. 우선순위
![[Pasted image 20240219143855.png]]
인터럽트 비트를 비활성화해도 무시할 수 없는 인터럽트 : NMI(Non-Maskable Interrupt)

PIC (Programmable Interrupt Controller) : 하드웨어
- 여러 장치 컨트롤러에 연결된다.
- 장치 컨트롤러에서 보낸 하드웨어 인터럽트 요청들의 우선순위 판별
- CPU에게 우선순위를 알려준다.
- 핀을 통해 사용한다.
![[Pasted image 20240219144039.png]]
1. PIC가 장치컨트롤러에서 **인터럽트 요청신호**를 받아들인다.
2. PIC가 우선순위 판단, CPU에게 처리해야 할 애를 알려준다.
3. CPU가 PIC에 **인터럽트 확인 신호**
4. PIC가 데이터버스로 **인터럽트 벡터** 보냄
5. CPU는 해당 장치의 **인터럽트 서비스 루틴** 실행

## DMA 입출력

#### 위의 입출력의 단점

입출력 데이터를 메모리에 저장하는 경우
1. CPU가 장치컨트롤러에서 데이터를 가져와 레지스터에 적재한다.
2. 적재한 데이터를 메모리에 저장한다.
![[Pasted image 20240219150006.png]]
메모리 속 데이터를 입출력장치에 내보내는 경우
1. 메모리에서 꺼내서 레지스터에 적재
2. 적재한 데이터를 입출력에 보낸다.
![[Pasted image 20240219150048.png]]


이게 왜 불편할까?
우리 (메모리, 입출력장치)는 그냥 서로 통신만 하면 되는건데,
CPU가 중간에 자꾸 끼게되서 동선낭비가 된다.
+CPU가 할일을 뺏긴다.
따라서 그냥 CPU를 없애고 **다이렉트로 메모리에 접근할 수 있도록 하자**가 되는거임

### DMA
Direct Memory Access
**직접 메모리에 접근할 수 있는 입출력 기능**

DMA입출력을 하기 위해서는 시스템 버스에 연결된 **DMA 컨트롤러**라는 하드웨어가 필요하다.
![[Pasted image 20240219150317.png]]

#### DMA 입출력 과정
1. CPU는 DMA컨트롤러에 입출력장치 주소, 연산, 메모리 주소 같은 정보로 입출력 작업을 명령한다.
2. DMA컨트롤러가 CPU대신 장치컨트롤러와 상호작용한다.
	1. 필요한 경우 메모리에 직접 접근하여 정보를 읽거나 쓴다.
3. 입출력 끝나면 DMA 컨트롤러는 CPU에 인터럽트를 걸어 작업이 끝났다고 알림

- **입출력장치와 메모리 사이에 주고받을 데이터는 CPU를 거치지 않는다!!**
- 그냥 명령만 시키고, 보고만 받으면 되는 거임!

**문제**
DMA컨트롤러는 시스템 버스 :=> 메모리에 직접 접근 가능
하지만 시스템 버스는 동시 사용이 불가능하다. (공용자원이기 때문에!)

CPU가 시스템 버스를 쓸 때, DMA 컨트롤러는 못쓴다는거임
1. 이용하지 않을 때 쓴다
2. 양해를 구한다.
![[Pasted image 20240219150753.png]]
이런걸 싸이클 스틸링이라고 한다.

#### 입출력버스
위의 DMA를 보면 DMA를 위해 한 번 메모리에 접근할 때마다 시스템 버스를 두 번 사용하게 되는 부작용이 있다.
![[Pasted image 20240219150907.png]]
1. 메모리에서 DMA컨트롤러로 데이터를 가져올 때
2. DMA컨트롤러 데이터 => 장치컨트롤러로 옮길 때

근데!!!!!
시스템 버스도 CPU가 써야한다고.......
그래서 DMA 컨트롤러와 장치컨트롤러 사이를 **입출력 버스**라는 별도의 버스에 연결한다는 것!!
![[Pasted image 20240219151027.png]]