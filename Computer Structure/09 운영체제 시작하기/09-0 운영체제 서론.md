### 운영체제의 역할

> 운영체제는 컴퓨터의 자원을 독점적으로 관리하는 특별한 소프트웨어이다.
> 	컴퓨터의 자원을 추상화(숨김)
> 	 그것들을 관리, 인터페이스를 제공

이것들을 => **효율적, 안정적, 확장도 잘되게 편리하게 해준다!**

**한 마디 요약 : 컴퓨터의 자원을 잘~~ 쓰게 해준다!!!**

### 운영체제의 역사
1. 고정 프로그래밍 방식
2. 내장 프로그래밍 방식
3. 대화형 시스템
4. 다중프로그래밍

#### 고정 프로그래밍 방식
이 시절에서의 컴퓨터 : 논리 Gate의 조합
- 하나의 기계 : 하나의 기능
- 하드 와이어링이 되어있어, 기능추가는 거의 불가능하다.
굉장히 불편하고, 힘든 작업의 연속이다!

#### 내장 프로그래밍 방식(Batch processing, 일괄작업 시스템)

OMR카드를 생각해보자

천공카드 리더 : 입력장치
라인 프린터 : 출력장치로 사용해서
CPU와 로직 저장장치(메모리)를 분리해서 사용했다.

여기서는 작업을 한 번에 하나씩 밖에 처리를 못했다.
OMR이 수정이 불가능하지 않는가?
- 모든 작업을 한꺼번에 처리하고
- 프로그램 실행 중간에 사용자가 데이터를 입력하거나 수정하는 것이 불가능한 시스템

이래서.....

#### 대화형 시스템
모니터와 키보드가 등장했다!

프로그램이 진행되는 도중
- 입력을 할 수 있다. => **입력 값에 따라 작업의 흐름을 바꿀 수 있다.**

하지만, 컴퓨터가 하나의 작업만 하도록 하기에는 정말 가격이 비싸다.
=> 하나의 CPU에서 하나의 작업을 하는건 너무 아깝다.
=> **다중 프로그래밍**


## 다중프로그래밍

**하나의 CPU로 여러 작업을 동시에 실행하는 기술**

이름과 설명을 보면 동시에 실행을 하는 것 처럼 보이는데, 엄밀하게 말하면 동시에 시작은 아니다.
> 간격을 짧게 짧게, 잘게 잘게 나눠서 사용자 입장에서는 동시에 실행이 되는 것처럼 보인다는 것!!!!!!

**고급 표현**
- 각 작업당 CPU 사용시간을 분할한다. => 여러 작업이 동시에 실행되는 것처럼 보이게 한다.
- 프로그램 실행도중 I/O가 발생하여 대기할 때, 메모리에 적재된 다른 프로그램이 실행된다.


A : 1초, B : 1초, C : 1초의 작업이 있다면
A->B->C 순서로 하는게 아니라
0.0001초씩 막 나눠서 task를 처리하겠다는 것

하지만!!! 다중프로그래밍이 만악의 근원이 된다.

여러가지 문제가 생기게 된다는 것
1. 어떤 작업을 언제 처리해야 할까? => 그 작업:프로세스 , **프로세스에 대한 관리**
2. 그럼 작업을 처리하려면 메모리에 올려야 한다. 근데 메모리는 너무 작다. 그러면 한정된 메모리에 어떤 작업을 올려줘야 할까? => **메모리 관리**
3. 그럼 나머지 작업들은 메모리가 아니라 어디에 보관하지? => **파일 시스템 관리**
4. 이상 없이 잘 실행되나? => **통계 등 기타관리**

또 더 나아가, 우리는 결국 사람들과 소통해야 한다.
컴퓨터간 정보 전송을 경제적이고 현실적 수준으로 전환해야 한다.

=> 장치 외부까지 관리하기 위해서는 외부의 장치를 고려하여 운영체제의 기능의 확장이 필요하다!!

5. 네트워크를 지원하기 위한 장치 및 프로토콜들의 지원, 리소스 제어 => **네트워크 관리**
6. 그렇다면 다른 사용자가 들어오지 않나?? ㅜㅜ 위험하다 => **보안관리**
7. 그렇다면 다른 사용자가 내 시스템을 사용하는 지 확인 => **사용자 관리 등 기타**

이걸 다 운영체제 햄이 한다는 거다.

이제야 운영체제 햄의 위대함을 알았나?
